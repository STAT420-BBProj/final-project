---
title: "Final Project"
author: "Team 27 - Mark Berman, Joel Kopp, and Richard Wheeler"
date: "7/23/2018"
output: 
  html_document:
     toc: yes
     toc_depth: 5
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(width = 132)
```

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
### function that calculates average percent error using actual wins and ###
### predicted wins from test data ###
calc_average_pct_error <- function(model) {
  test_predicted_wins <- predict(model, newdata = bbproj_tst)
  abs_dif <- abs(test_predicted_wins - bbproj_tst$W)
  avg_pct_error <- mean(abs_dif/test_predicted_wins) * 100
  rmse <- sqrt(mean(bbproj_tst$W - test_predicted_wins) ^ 2)
  list(predicted_wins = test_predicted_wins, 
       avg_pct_error = avg_pct_error, 
       rmse = rmse)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
### function that plots actual wins versus predicted wins from test data
plot_predicted_wins_versus_actual_wins <- function(model_name, 
                                                   predicted_wins, 
                                                   actual_wins, 
                                                   avg_pct_error, rmse) {
  xrange <- c(0, max(actual_wins + 10))
  yrange <- c(0, max(predicted_wins + 10))
  title <- paste(model_name, " : 2014 - 2016 Baseball Seasons")
  sub <- paste("Average Percent Error: ", round(avg_pct_error,2), " %", 
               "   Test RMSE: ", round(rmse,2))
  plot(predicted_wins ~ actual_wins, 
       pch = 20, 
       col = "grey", 
       cex = 1.5, 
       xlab = "Actual Wins", 
       ylab = "Predicted Wins", 
       main= title, 
       sub=sub, 
       xlim=xrange, 
       ylim=yrange)
  abline(a = 0, b = 1, col = "darkorange")
}
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
### function that plots fitted values versus residuals for training data ###
plot_fitted_versus_residuals <- function(fitted_values, residuals, model_name) {
  plot(fitted_values, residuals, 
       col = "grey", 
       pch = 20, 
       xlab = "Fitted", 
       ylab = "Residuals", 
       main = model_name)
  abline(h = 0, col = "darkorange", lwd = 2)
}
```

```{r message = FALSE, warning = FALSE}
library(readr)
library(lmtest)
library(faraway)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
### calculate cross validated RMSE for models using training data
calc_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
### calculate cross validated RMSE for models using training data
model_diagnostics = function(model) {
  print("Variance Inflation Factors")
  print(vif(model))
  print(paste("Number of coefficients with VIF > 5: ", sum(vif(model) > 5)))
  print(bptest(model))
  print(shapiro.test(resid(model)))
  print(paste("Leave One Out Cross-Validated RMSE: ", 
              round(calc_loocv_rmse(model), 2)))
  std_resid <- rstandard(model)[abs(rstandard(model)) > 2]
  is_std_resid_gt_five_percent <- length(std_resid) / n > 0.05
  print(ifelse(is_std_resid_gt_five_percent, "Outliers Exceed 5% of Obs", 
               "Outliers Do Not Exceed 5% of Obs"))
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
### load training data and clean it up ###
bbproj_trn <- read_csv("bbproj_trn.csv",na = c("", "NA"))
bbproj_trn$X1 <- NULL
bbproj_trn$lgID <- NULL
bbproj_trn$teamID <- NULL
bbproj_trn$divID <- NULL
bbproj_trn$Rank <- NULL
bbproj_trn$G <- NULL
bbproj_trn$Ghome <- NULL
bbproj_trn$L <- NULL
bbproj_trn$name <- NULL
bbproj_trn$teamIDBR   <- NULL
bbproj_trn$teamIDlahman45 <- NULL
bbproj_trn$teamIDretro <- NULL
bbproj_trn$DivWin <- as.factor(bbproj_trn$DivWin)
bbproj_trn$WCWin <- as.factor(bbproj_trn$WCWin)
bbproj_trn$LgWin <- as.factor(bbproj_trn$LgWin)
bbproj_trn$WSWin <- as.factor(bbproj_trn$WSWin)
bbproj_trn$franchID <- as.factor(bbproj_trn$franchID)
bbproj_trn$park <- as.factor(bbproj_trn$park)
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
### load test data and clean it up ###
bbproj_tst <- read_csv("bbproj_tst.csv",na = c("", "NA"))
bbproj_tst$X1 <- NULL
bbproj_tst$lgID <- NULL
bbproj_tst$teamID <- NULL
bbproj_tst$divID <- NULL
bbproj_tst$Rank <- NULL
bbproj_tst$G <- NULL
bbproj_tst$Ghome <- NULL
bbproj_tst$L <- NULL
bbproj_tst$name <- NULL
bbproj_tst$teamIDBR   <- NULL
bbproj_tst$teamIDlahman45 <- NULL
bbproj_tst$teamIDretro <- NULL
bbproj_tst$DivWin <- as.factor(bbproj_tst$DivWin)
bbproj_tst$WCWin <- as.factor(bbproj_tst$WCWin)
bbproj_tst$LgWin <- as.factor(bbproj_tst$LgWin)
bbproj_tst$WSWin <- as.factor(bbproj_tst$WSWin)
bbproj_tst$franchID <- as.factor(bbproj_tst$franchID)
bbproj_tst$park <- as.factor(bbproj_tst$park)
```

***

# Introduction #

Conventional wisdom is that money buys happiness (winning) in Major League Baseball.  However, the advent of "Moneyball" in the early 2000s by the Oakland Athletics, Cleveland Indians, and other teams, has lead to a more analytical approach to determining the make-up of Major League rosters.  

As it turns out, money is not the magic elixir when it comes to assembling a winning Major League Baseball (MLB) team.  The following plot shows that salary does not highly correlate with a winning record.  This is substantiated by the companion single linear regression model and summary statistics that show that salary, while significant, only has a marginal impact on wins by an MLB team. The adjusted *$R^2$* from the simple linear regression -- using training data from 2000 through 2013 -- is low.  Furthermore, the *average percent error* that compares actual wins versus predicted wins from the the test data (2014 through 2016) is high.

```{r echo=FALSE, message=FALSE, warning=FALSE}
options(scipen = 10)
xrange <- c(min(bbproj_trn$salary - 1000000), max(bbproj_trn$salary + 1000000))
yrange <- c(0, max(bbproj_trn$W + 10))
plot(bbproj_trn$W ~ bbproj_trn$salary, 
     pch = 20, 
     col = "grey", 
     cex = 1.5, 
     xlab = "Salary (US $)", 
     ylab = "Wins", 
     main= "Actual Salary vs Actual Wins (2000 - 2013)", 
     xlim=xrange, 
     ylim=yrange, 
     type="p")
abline(a = 81, b = 0, col = "darkorange")
legend("bottomright", 
        cex = 1.0, 
        bty = "n", 
        legend = c("training observations", "81 WINS"), 
        text.col = c("grey", "darkorange"),
        col = c("grey", "darkorange"), 
        pch = c(16, 15))
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
salary_only_model <- lm(W ~ salary, data = bbproj_trn)
summary(salary_only_model)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(paste("Leave One Out Cross-Validated RMSE: ", 
            round(calc_loocv_rmse(salary_only_model), 2)))
```

```{r message=FALSE, message=FALSE, warning=FALSE, include=FALSE}
### average percent error for the salary only model ###
result <- calc_average_pct_error(salary_only_model)
avg_pct_error_salary_only_model <- result$avg_pct_error
predicted_wins_salary_only_model <- result$predicted_wins
rmse_salary_only_model <- result$rmse
```

```{r echo=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
### Plot predicted vs actual wins for the smaller step search aic model
plot_predicted_wins_versus_actual_wins("Salary Only Model", 
                                       predicted_wins_salary_only_model, 
                                       bbproj_tst$W, 
                                       avg_pct_error_salary_only_model, 
                                       rmse_salary_only_model)
```

So what are the factors that move the needle?

We explore two related threads in attempting to identify the factors that have a strong impact on a winning baseball team.

The first thread uses multiple linear regression to identify the factors that influence a team's winning record over the course of a regular Major League Baseball (MLB) season.  
The second thread uses logistic regression to identify the factors that influence a team's ability to win their division.

## Data ##

A few words are in order about where we obtained the data from to perform this analysis.

The source of data is the Sean Lahman baseball archive (http://www.seanlahman.com/baseball-archive/), recognized by the *Society for American Baseball Research* (SABR) as the leading detailed player and team data archive from 1874 through the end of the 2017 Major League Baseball season.  We use team statistics from the years 2000 through 2013 as the training dataset and use data from 2014 through 2016 as the test dataset.  (As a note, we were unable to include the 2017 season in our analysis due to unavailability of salary data.)

### Variables ###

The team-based variables we examine fall into one of three categories: offensive, defensive, or administrative.

#### Administrative ####

- `yearID` - Year
- `franchID` - Franchise, or team name
- `W` - **Wins (multiple linear regression response variable)**
- `DivWin` - **Division winner (Y or N factor- Logistic linear regression response variable)**
- `WCWin` - Wild Card winner (Y or N factor)
- `LgWin` - League champion (Y or N factor)
- `WSWin` - World Series winner (Y or N factor)
- `salary` - Team Salary (U.S dollars not adjusted for inflation)

#### Offensive ####

- `R` - Runs scored
- `AB` - At bats
- `H` - Total hits (including doubles, triples, and home runs)
- `X1B` - Singles
- `X2B` - Doubles
- `X3B` - Triples
- `HR` - Home runs
- `BB` - Base on balls (walks)
- `SO` - Strikeouts
- `SB` - Stolen bases
- `CS` - Caught stealing
- `HBP` - Hit by pitch
- `SF` - Sacrifice flies
- `park` - Name of team's home ballpark (factor)
- `attendance` - Home attendance total
- `BPF` - Three-year park factor for batters
- `GIDP` - Grounded into double plays
- `RBI` - Runs Batted In
- `IBB` - Intentional walks
- `TB` - Total bases
- `SLG` - Slugging percentage
- `OBP` - On-base percentage
- `OPS` - On-base plus slugging percentage
- `BABIP` - Batting average for balls in play
- `RC` - Runs created
- `uBB` - Unintentional walks
- `wOBA` - Weighted on-base average

#### Defensive ####

- `RA` - Total runs allowed
- `ER` - Earned runs allowed
- `ERA` - Earned run average
- `CG` - Complete games
- `SHO` - Shutouts
- `SV` - Saves
- `IPOuts` - Outs pitched
- `HA` - Hits allowed
- `HRA` - Home runs allowed
- `BBA` - Walks allowed
- `SOA` - Strikeouts by pitchers
- `E` - Errors
- `DP` - Double plays
- `FP` - Fielding percentage
- `PPF` - Three-year park factor for pitchers
- `WHIP` - Walks and hits per innings pitched

***

# The Search for Better Multiple Linear Regression Models For Predicting Regular Season Team Wins #

## Methodology ##

The goal of this thread is to find a Multiple Linear Regression (MLR) model that is simple enough to explain the relationship between the response variable (regular season wins) and the predictors.  In essence, we are interested a reasonably small MLR model that is easy to interpret.  Equally important is the need for the model to predict well against the test data set from the 2014, 2015 and 2016 MLB regular seasons.  This means we have to sacrifice a certain degree of model simplicity.  In short, we are trying to find a model that will allow us to "have our cake and eat it too".

The approach we take is to employ all three search procedures -- *Backward*, *Forward* and *Stepwise* -- against the *Akaike Information Criterion* (AIC) and the *Bayesian Information Criterion* (BIC) quality criterion in order to find the model that best meets the goals of this thread.

We start by creating the following six initial models. 

- Backward Search - BIC Model
- Backward Search - AIC Model
- Step Search - BIC Model
- Step Search - AIC Model
- Forward Search - BIC Model
- Forward Search - AIC Model.

We then use an iterative process of model evaluation and refinement until we have produced a lineup of candidate models that move on to the next phase of assessment:  prediction against the test dataset.

The model evaluation and refinement process utilizes the following six diagnostics tests.

- Breusch-Pagan Test (BP Test) to assess whether each of the six initial models meets the equal variance of residuals requirement.  A *p_value* greater than *0.05* indicates a high likelihood that a given model's errors have constant variance.
- Shapiro-Wilk Test to assess whether each of the six initial models meet the normal distribution of residuals requirement.  A *p_value* greater than *0.05* indicates a high likelihood that a given model's errors are normally distributed.
- A count of the number of unusual observations.  The test counts the number of standardized residuals that exceed a magnitude of 2. The threshold for concern is when the count exceeds 5% of the total number of observations.
- Leave One Out Cross-Validated RMSE (LOOCV-RMSE) to assess how well a given model generalizes to unseen observations (e.g., the test data).  The smaller the value, the more likely a given model
will do a good job predicting the response variable (in this case, regular season wins by an MLB team).
- Calculation of the Variance Inflation Factor (VIF) for each of the estimated predictor coefficients ($\hat{\beta}_j$).  A VIF score greater than 5 indicates that a given predictor is highly collinear.
- A check to make sure that the each estimated predictor coefficient ($\hat{\beta}_j$) is likely significant by rejecting the null hypothesis $H_0: B_j = 0$.  We fail to reject $H_0: B_j = 0$ when $\hat{\beta}_j$ has a *p_value* greater than *$\alpha = 0.05$*.

If a model passes all six of these diagnostic tests then it is considered worthy of being evaluated against the test dataset.  From a nomenclature perspective, each model that passes this hurdle is called *candidate* model.  If a model does not pass all six of these diagnostic tests we refit the model after removing a single predictor.  We then perform the same six diagnostic tests. We repeat this cycle until a model is produced that passes all six of the diagnostic tests. 

Once *candidate* models are identified, we assess their ability to predict regular season team wins against the test dataset.  The *candidate* model with the lowest 
*Average Percent Error* and the lowest *Test RMSE* is declared the winner.

Please note that the response variable is designated as `W` in models that are described below.

### The Six Initial Multiple Linear Regression Models ###

```{r}
scope <- W ~ R + AB + H + X2B + X3B + HR + BB + SO + SB + CS + HBP + SF + RA + 
  ER + ERA + CG + SHO + SV + IPouts + HA  + HRA + BBA + SOA + E + DP + FP + 
  attendance + BPF + PPF + salary + RBI + GIDP + IBB + TB + SLG + OBP + OPS + 
  WHIP + BABIP + RC + X1B + uBB + wOBA

formula <- formula(scope)
start_model <- lm(formula, data= bbproj_trn)
n <- length(resid(start_model))
step_search_start_model <- lm(W ~ 1, data= bbproj_trn)
```

#### Backwards Search: BIC Model ####

```{r}
### Backwards Search: BIC Model
bic_model <- step(start_model,  direction = "backward", k = log(n), trace = 0)
summary(bic_model)
```

#### Backwards Search: AIC Model ####

```{r}
### Backwards Search: AIC Model
aic_model <- step(start_model, direction = "backward", trace = 0)
summary(aic_model)

```

#### Step Search: BIC Model ####

```{r}
### Step Search: BIC Model
step_bic_model <- step(step_search_start_model, scope = scope, direction = "both",
                       k = log(n), trace = 0)
summary(step_bic_model)
```


#### Step Search: AIC Model ####

```{r}
### Step Search: AIC Model ### 
step_aic_model <- step(step_search_start_model, scope = scope, 
                       direction = "both", trace = 0)
summary(step_aic_model)
```


#### Forward Search: BIC Model ####

```{r}
bic_forward_model <- step(step_search_start_model, scope = scope, 
                          k = log(n), trace = 0)
summary(bic_forward_model)
```

#### Forward Search: AIC Model ####

```{r}
aic_forward_model <- step(step_search_start_model, scope = scope, trace = 0)
summary(aic_forward_model)
```

### Identifying Which of the Six Initial Models Make The Cut as Candidate Models ###

#### Evaluation of the Backwards Search: BIC Model ####
```{r}
### Breusch-Pagan Test on Backwards Search - BIC Model
bptest(bic_model)
```

```{r}
plot_fitted_versus_residuals(fitted(bic_model), 
                             resid(bic_model), 
                             "Backwards Search - BIC Model")
```

```{r}
### Shapiro - Wilk Normality Test on Backwards Search - BIC Model ###
shapiro.test(resid(bic_model))
```

```{r}
qqnorm(resid(bic_model), 
       main = "Normal Q-Q Plot, Backwards Search - BIC Model", 
       col = "darkgrey")
qqline(resid(bic_model), col = "dodgerblue", lwd = 2)
```

```{r}
print(paste("Leave One Out Cross-Validated RMSE: ", 
            round(calc_loocv_rmse(bic_model), 2)))
```

```{r}
### Do the number of standard residuals greater than 2 exceed 5% of the total 
### observations -- Backwards Search: BIC Model
std_resid_bic_model <- rstandard(bic_model)[abs(rstandard(bic_model)) > 2]
is_std_resid_gt_five_percent_bic_model <- 
  length(std_resid_bic_model) / n > 0.05
ifelse(is_std_resid_gt_five_percent_bic_model, 
       "Outliers Exceed 5% of Obs", 
       "Outliers Do Not Exceed 5% of Obs")
```

```{r}
### VIF > 5 for Backwards Search: BIC Model Coefficients
vif_bic_model <- vif(bic_model)
vif_bic_model[which(vif_bic_model > 5)]
```

#### Refining the Backwards Search: BIC Model Due to High Variance Inflation Factors ####

```{r message = FALSE, warning = FALSE}
library(caret)
```

```{r}
bic_model_high_vif_cols <- c("R", "AB", "H", "BB", "SO", "RA", "E", "FP",
                             "BABIP", "RC")
indices_to_drop <- findCorrelation(cor(bbproj_trn[,c(bic_model_high_vif_cols)]), 
                                   cutoff = 0.6)
(vars_to_drop <- bic_model_high_vif_cols[indices_to_drop])
```

##### A Better And Smaller Backwards Search: BIC Model #####

```{r}
smaller_bic_model <- lm(W ~ AB + BB + SO + SF + RA + CG + SV + IPouts + BBA + 
                          BABIP, data = bbproj_trn)
summary(smaller_bic_model)
```

##### Diagnostics for the Better and Smaller Backwards Search: BIC Model #####

```{r}
model_diagnostics(smaller_bic_model)
```

The Smaller Backward Search: BIC model passes all six of the diagnostic tests.  It is deemed as a candidate model for the next phase: evaluation of the model's predictive capability against the test dataset.

#### Evaluation of the Backwards Search: AIC Model ####

```{r}
### Breusch-Pagan Test on AIC Model
bptest(aic_model)
```

```{r}
plot_fitted_versus_residuals(fitted(aic_model), resid(aic_model), 
                             "Backwards Search - AIC Model")
```

```{r}
### Shapiro - Wilk Normality Test on Backwards Search - AIC Model ###
shapiro.test(resid(aic_model))
```

```{r}
qqnorm(resid(aic_model), 
       main = "Normal Q-Q Plot, Backwards Search - AIC Model", 
       col = "darkgrey")
qqline(resid(aic_model), col = "dodgerblue", lwd = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(paste("Leave One Out Cross-Validated RMSE: ", 
            round(calc_loocv_rmse(aic_model), 2)))
```

```{r}
### Do the number of standard residuals greater than 2 exceed 5% of the total 
### observations -- Backwards Search: AIC Model
std_resid_aic_model <- rstandard(aic_model)[abs(rstandard(aic_model)) > 2]
is_std_resid_gt_five_percent_aic_model <- 
  length(std_resid_aic_model) / n > 0.05
ifelse(is_std_resid_gt_five_percent_aic_model, 
       "Outliers Exceed 5% of Obs", 
       "Outliers Do Not Exceed 5% of Obs")
```


```{r}
### VIF > 5 for Backwards Search: AIC Model Coefficients
vif_aic_model <- vif(aic_model)
vif_aic_model[which(vif_aic_model > 5)]
```

#### Refining the Backwards Search: AIC Model Due to High Variance Inflation Factors ####

```{r}
aic_model_high_vif_cols <- c("R", "AB", "H", "X2B", "X3B", "HR", "BB", "SO", 
                             "SF", "RA", "ER", "IPouts", "E", "FP","BPF", 
                             "PPF", "IBB", "OBP", "BABIP", "RC", "wOBA")
indices_to_drop <- findCorrelation(cor(bbproj_trn[,c(aic_model_high_vif_cols)]), 
                                   cutoff = 0.6)
(vars_to_drop <- aic_model_high_vif_cols[indices_to_drop])
```

##### A Better And Smaller Backwards Search: AIC Model #####

```{r}
smaller_aic_model <-  lm(formula = W ~  HR + BB + SO + ER + CG + SHO + SV + 
                           IPouts + BBA + FP + GIDP + BABIP, data = bbproj_trn)
summary(smaller_aic_model)
```

##### Diagnostics for the Better and Smaller Backwards Search: AIC Model #####

```{r}
model_diagnostics(smaller_aic_model)
```

The Smaller Backward Search: AIC model does not pass all six of the diagnostic tests.  The Shapiro-Wilk p-value is smaller than the threshold of $\alpha = 0.05$. As a result, we reject the null hypothesis that the residuals are normally distributed. As such, this model is not deemed a *candidate* model and is not passed on to the next evaluation phase.

#### Evaluation of the Step Search: BIC Model ####

```{r}
### Breusch-Pagan Test on Step BIC Model
bptest(step_bic_model)
```

```{r}
plot_fitted_versus_residuals(fitted(step_bic_model), resid(step_bic_model), 
                             "Step Search - BIC Model")
```

```{r}
### Shapiro - Wilk Normality Test on Step Search - BIC Model ###
shapiro.test(resid(step_bic_model))
```

```{r}
qqnorm(resid(step_bic_model), 
       main = "Normal Q-Q Plot, Step Search - BIC Model", 
       col = "darkgrey")
qqline(resid(step_bic_model), col = "dodgerblue", lwd = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(paste("Leave One Out Cross-Validated RMSE: ", 
            round(calc_loocv_rmse(step_bic_model), 2)))
```

```{r}
### Do the number of standard residuals greater than 2 exceed 5% of the total
### observations -- Step Search: BIC Model
std_resid_step_bic_model <- rstandard(
  step_bic_model)[abs(rstandard(step_bic_model)) > 2]
is_std_resid_gt_five_percent__step_bic_model <- length(
  std_resid_step_bic_model) / n > 0.05
ifelse(is_std_resid_gt_five_percent__step_bic_model, "Exceeds 5% of Obs", 
       "Does Not Exceed 5% of Obs")
```


```{r}
### VIF > 5 for Step Search: BIC Model Coefficients
vif_step_bic_model <- vif(step_bic_model)
vif_step_bic_model[which(vif_step_bic_model > 5)]
```

#### Refining the Step Search: BIC Model Due to High Variance Inflation Factors ####

##### A Better And Smaller Step Search: BIC Model #####

```{r}
smaller_step_bic_model <- lm(formula = W ~ SV + R + RA + SHO + CG + X3B + 
                               IPouts + AB + salary, data = bbproj_trn)
summary(smaller_step_bic_model)
```

##### Diagnostics for the Better and Smaller Step Search: BIC Model #####

```{r}
model_diagnostics(smaller_step_bic_model)
```

The Smaller Step Search: BIC model passes all six of the diagnostic tests.  It is deemed as a *candidate* model for the next phase: evaluation of the model's predictive capability against the test dataset.

#### Evaluation of the Step Search: AIC Model ####

```{r}
### Breusch-Pagan Test on Step AIC Model
bptest(step_aic_model)
```

```{r}
plot_fitted_versus_residuals(fitted(step_aic_model), resid(step_aic_model), 
                             "Step Search - AIC Model")
```

```{r}
### Shapiro - Wilk Normality Test on Step Search - AIC Model ###
shapiro.test(resid(step_aic_model))
```

```{r}
qqnorm(resid(step_aic_model), 
       main = "Normal Q-Q Plot, Step Search - AIC Model", 
       col = "darkgrey")
qqline(resid(step_aic_model), col = "dodgerblue", lwd = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(paste("Leave One Out Cross-Validated RMSE: ", 
            round(calc_loocv_rmse(step_aic_model), 2)))
```

```{r}
### Do the number of standard residuals greater than 2 exceed 5% of the total
### observations -- Step Search: AIC Model
std_resid_step_aic_model <- rstandard(
  step_aic_model)[abs(rstandard(step_aic_model)) > 2]
is_std_resid_gt_five_percent__step_aic_model <- length(
  std_resid_step_aic_model) / n > 0.05
ifelse(is_std_resid_gt_five_percent__step_aic_model,
       "Exceeds 5% of Obs", 
       "Does Not Exceed 5% of Obs")
```

```{r}
### VIF > 5 for Step Search: AIC Model Coefficients
vif_step_aic_model <- vif(step_aic_model)
vif_step_aic_model[which(vif_step_aic_model > 5)]
```

#### Refining the Step Search: AIC Model Due to High Variance Inflation Factors ####

##### A Better And Smaller Step Search: AIC Model #####

```{r}
smaller_step_aic_model <- lm(formula = W ~ SV + R + SHO + CG + X3B + IPouts + 
                               BBA + HRA + SOA, data = bbproj_trn)
summary(smaller_step_aic_model)
```

##### Diagnostics for the Better and Smaller Step Search: AIC Model #####

```{r}
model_diagnostics(smaller_step_aic_model)
```

The Smaller Step Search: AIC model passes all six of the diagnostic tests.  It is deemed as a *candidate* model for the next phase: evaluation of the model's predictive capability against the test dataset.

#### Evaluation of the Forward Search: BIC Model ####
```{r}
### Breusch-Pagan Test
bptest(bic_forward_model)
```

```{r}
plot_fitted_versus_residuals(fitted(bic_forward_model), 
                             resid(bic_forward_model), 
                             "Forward Search - BIC Model")
```

```{r}
### Shapiro - Wilk Normality Test ###
shapiro.test(resid(bic_forward_model))
```

```{r}
qqnorm(resid(bic_forward_model), 
       main = "Normal Q-Q Plot, Step Search - BIC Model", col = "darkgrey")
qqline(resid(bic_forward_model), col = "dodgerblue", lwd = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(paste("Leave One Out Cross-Validated RMSE: ", 
            round(calc_loocv_rmse(bic_forward_model), 2)))
```

```{r}
### Do the number of standard residuals greater than 2 exceed 5% of the total 
### observations -- Step Search: AIC Model
std_resid <- rstandard(bic_forward_model)[abs(rstandard(bic_forward_model)) > 2]
is_std_resid_gt_five_percent <- length(std_resid) / n > 0.05
ifelse(is_std_resid_gt_five_percent, "Exceeds 5% of Obs", 
       "Does Not Exceed 5% of Obs")
```

```{r}
### VIF > 5 for Step Search: AIC Model Coefficients
vifs <- vif(bic_forward_model)
vifs[which(vifs > 5)]
```

#### Refining the Forward Search: BIC Model Due to High Variance Inflation Factors ####

```{r}
high_vif_cols <- as.array(names(vifs[which(vifs > 5)]))
indices_to_drop <- findCorrelation(cor(bbproj_trn[,c(high_vif_cols)]), 
                                   cutoff = 0.6)
(vars_to_drop <- high_vif_cols[indices_to_drop])
```

##### A Better And Smaller Forward Search: BIC Model #####

```{r}
terms = attr(bic_forward_model$terms, "term.labels")
terms = terms[! terms %in% vars_to_drop]
formula = as.formula(paste("W ~", paste(terms, collapse = "+")))
smaller_model <- lm(formula = formula, data = bbproj_trn)
summary(smaller_model)
smaller_bic_forward_model = smaller_model
```

##### Diagnostics for the Better and Smaller Forward Search: BIC Model #####

```{r}
model_diagnostics(smaller_bic_forward_model)
```

The Smaller Forward Search: BIC model passes all six of the diagnostic tests.  It is deemed as a *candidate* model for the next phase: evaluation of the model's predictive capability against the test dataset.

#### Evaluation of the Forward Search: AIC Model ####

```{r}
### Breusch-Pagan Test
bptest(aic_forward_model)
```

```{r}
plot_fitted_versus_residuals(fitted(aic_forward_model), 
                             resid(aic_forward_model), 
                             "Forward Search - AIC Model")
```

```{r}
### Shapiro - Wilk Normality Test ###
shapiro.test(resid(aic_forward_model))
```

```{r}
qqnorm(resid(aic_forward_model), 
       main = "Normal Q-Q Plot, Step Search - AIC Model", col = "darkgrey")
qqline(resid(aic_forward_model), col = "dodgerblue", lwd = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(paste("Leave One Out Cross-Validated RMSE: ", 
            round(calc_loocv_rmse(aic_forward_model), 2)))
```

```{r}
### Do the number of standard residuals greater than 2 exceed 5% of the total 
### observations -- Step Search: AIC Model
std_resid <- rstandard(aic_forward_model)[abs(rstandard(aic_forward_model)) > 2]
is_std_resid_gt_five_percent <- length(std_resid) / n > 0.05
ifelse(is_std_resid_gt_five_percent,"Exceeds 5% of Obs", 
       "Does Not Exceed 5% of Obs")
```

```{r}
### VIF > 5 for Step Search: AIC Model Coefficients
vifs <- vif(aic_forward_model)
vifs[which(vifs > 5)]
```

#### Refining the Forward Search: AIC Model Due to High Variance Inflation Factors ####

```{r}
high_vif_cols <- as.array(names(vifs[which(vifs > 5)]))
indices_to_drop <- findCorrelation(cor(bbproj_trn[,c(high_vif_cols)]), 
                                   cutoff = 0.6)
vars_to_drop <- high_vif_cols[indices_to_drop]
vars_to_drop
```

##### A Better And Smaller Forward Search: AIC Model #####

```{r}
terms = attr(aic_forward_model$terms, "term.labels")
terms = terms[! terms %in% vars_to_drop]
formula = as.formula(paste("W ~", paste(terms, collapse = "+")))
smaller_model <-  lm(formula = formula, data = bbproj_trn)
summary(smaller_model)
smaller_aic_forward_model = smaller_model
```

##### Diagnostics for the Better and Smaller Forward Search: AIC Model #####

```{r}
model_diagnostics(smaller_aic_forward_model)
```

The Smaller Step Search: AIC model passes all six of the diagnostic tests.  It is deemed as a *candidate* model for the next phase: evaluation of the model's predictive capability against the test dataset. 

### Validate The Candidate Model Predictive Effectiveness Using Test Data  ###

We now move forward with five *candidate* models and predict MLB regular season team wins with our test dataset from the 2014, 2015 and 2016 MLB regular seasons.  (There are a total of 90 observations in the test dataset -- one observation for each team for 2014, 2015 and 2016.)

```{r echo=FALSE, message=FALSE, warning=FALSE}
### average percent error for the smaller backwards search bic model ###
result <- calc_average_pct_error(smaller_bic_model)
avg_pct_error_smaller_bic_model <- result$avg_pct_error
predicted_wins_smaller_bic_model <- result$predicted_wins
rmse_wins_smaller_bic_model <- result$rmse
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
### Plot predicted vs actual wins for the smaller step search bic model
plot_predicted_wins_versus_actual_wins("Smaller Backwards Search BIC Model",
                                       predicted_wins_smaller_bic_model, 
                                       bbproj_tst$W, 
                                       avg_pct_error_smaller_bic_model, 
                                       rmse_wins_smaller_bic_model)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
### average percent error for the smaller step search bic model ###
result <- calc_average_pct_error(smaller_step_bic_model)
avg_pct_error_smaller_step_bic_model <- result$avg_pct_error
predicted_wins_smaller_step_bic_model <- result$predicted_wins
rmse_wins_smaller_step_bic_model <- result$rmse
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
### Plot predicted vs actual wins for the smaller step search bic model
plot_predicted_wins_versus_actual_wins("Smaller Step Search BIC Model", 
                                       predicted_wins_smaller_step_bic_model, 
                                       bbproj_tst$W, 
                                       avg_pct_error_smaller_step_bic_model, 
                                       rmse_wins_smaller_step_bic_model)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
### average percent error for the smaller step search aic model ###
result <- calc_average_pct_error(smaller_step_aic_model)
avg_pct_error_smaller_step_aic_model <- result$avg_pct_error
predicted_wins_smaller_step_aic_model <- result$predicted_wins
rmse_smaller_step_aic_model <- result$rmse
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
### Plot predicted vs actual wins for the smaller step search aic model
plot_predicted_wins_versus_actual_wins("Smaller Step Search AIC Model", 
                                       predicted_wins_smaller_step_aic_model, 
                                       bbproj_tst$W, 
                                       avg_pct_error_smaller_step_aic_model,
                                       rmse_smaller_step_aic_model)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
### average percent error for the smaller backwards search bic model ###
result <- calc_average_pct_error(smaller_bic_forward_model)
avg_pct_error_smaller_bic_forward_model <- result$avg_pct_error
predicted_wins_smaller_bic_forward_model <- result$predicted_wins
rmse_wins_smaller_bic_forward_model <- result$rmse
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
### Plot predicted vs actual wins for the smaller step search bic model
plot_predicted_wins_versus_actual_wins("Smaller Forward Search BIC Model", predicted_wins_smaller_bic_forward_model, bbproj_tst$W, 
                                       avg_pct_error_smaller_bic_forward_model,
                                       rmse_wins_smaller_bic_forward_model)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
### average percent error for the smaller backwards search bic model ###
result <- calc_average_pct_error(smaller_aic_forward_model)
avg_pct_error_smaller_aic_forward_model <- result$avg_pct_error
predicted_wins_smaller_aic_forward_model <- result$predicted_wins
rmse_wins_smaller_aic_forward_model <- result$rmse
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
### Plot predicted vs actual wins for the smaller step search bic model
plot_predicted_wins_versus_actual_wins("Smaller Forward Search AIC Model",
                                       predicted_wins_smaller_aic_forward_model,
                                       bbproj_tst$W, 
                                       avg_pct_error_smaller_aic_forward_model, 
                                       rmse_wins_smaller_aic_forward_model)
```

## Results ## 

### And the Winning Linear Regression Model is... ###

While all models do a good job predicting the number of regular season wins by a MLB team, the **Smaller Step Search: BIC Model** produces the best results against the test dataset.  This model has the lowest *Average Percent Error* score and *Test RMSE* score basis the test dataset.  This model also generalizes the best against unseen observations.  This means there is a high likelihood this model will perform well against test data for the 2017 and 2018 MLB seasons.  This model also contains the second smallest number of predictors; and it also contains *Salary* as one of the predictors.  This means it is easy to explain the relationship between the response variable `W` and it predictors.  The fact that *Salary* is included as a predictor supports the original premise that *Salary*, while not a dominant predictor, is a marginally significant predictor of regular season MLB team wins.

The following table summarizes the key evaluation factors used to choose the best model from the five candidates.

```{r, message=FALSE, warning=FALSE, include=FALSE}
number_of_predictors <- c(10, 9, 9, 6,15)
salary_included_as_predictor <- c(FALSE, TRUE, FALSE, FALSE, TRUE)
loocv_RMSE <- c(4.95, 2.99, 4.05, 4.2,6.27)
average_percent_error <- c(5.51, 3.17, 4.07, 5.46, 6.27)
test_rmse <- c(0.47, 0.32, 0.97, 1.55, 3.25)
results_df <- data.frame(predictor_count = number_of_predictors, 
                         salary_included = salary_included_as_predictor, 
                         loocv_RMSE = loocv_RMSE, 
                         avg_pct_error= average_percent_error, 
                         test_rmse = test_rmse )
row.names(results_df) <- c("Smaller Backward Search: BIC Model", 
                           "Smaller Step Search: BIC Model", 
                           "Smaller Step Search: AIC Model",
                           "Smaller Forward Search: BIC Model", 
                           "Smaller Forward Search AIC Model")
colnames(results_df) <- c("Predictor Count", "Salary Included", 
                          "LOOCV_RMSE", 
                          "AVG % Error", 
                          "Test RMSE")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
kable(results_df, format = "markdown", padding = 4, align=c(rep('c', times=5)))
```

## Discussion ##

The winning model -- *Smaller Step Search: BIC* -- adds validity to the axiom that pitching wins games.  The key predictors that influence the number of regular season wins by an MLB team are related to pitching.

- Holding all other predictors constant, each additional *Save* increases the average number of wins by 0.40.
- Holding all other predictors constant, each additional *Shutout* increases the average number of wins by 0.17.
- Holding all other predictors constant, each additional *Complete Game* increases the average number of wins by 0.142.
- Holding all other predictors constant, each additional run given up by a pitcher (*Runs Against*) reduces the average number of wins by 0.7.

It is moderately surprising that offense related predictors do not dominate the model. (One of the authors of this study is a die-hard New York Yankees fan.  The New York Yankees are well known for slightly above average pitching but dominant offense.  The Yankees have 27 World Championships to date.  That said, the last championship occurred nine years ago.  So maybe there is more to good pitching that meets the eye.)  The one offense related predictor that moves the needle is *Runs*.  Holding all other predictors constant, an increase in 1 run per game increases the average number of wins by 0.10.

The most exciting play in baseball, the *Triple*, is negatively correlated with wins.  Holding all other predictors constant, an increase of 1 *Triple* reduces the average number of wins by 0.5.  This is a real "head-scratcher".

***

# Logistic Modeling and Prediction of Division Winners #

## Salary as a Predictor for Division Winners ##

For this second thread, let's turn our attention to logistic regression and our ability to classify and predict division winners using our team predictor set.  First, let's see how well salary alone can predict pennants.

```{r}
salary_only_model <- glm(DivWin ~ salary, data = bbproj_trn, family = binomial)
(salary_only_summary = summary(salary_only_model))
plot(as.numeric(DivWin) - 1 ~ salary, data = bbproj_trn, 
     pch = 20, 
     main = "Probability of Buying a Division Winner",
     ylab = "Probability of Winning Division", 
     xlab = "Team Salary ($)",  
     xlim = c(0, 3e8))
curve(predict(salary_only_model, data.frame(salary = x), type = "response"), 
      add = TRUE, 
      col = "tomato", 
      lty = 2,
      lwd = 2)
```

Graphically, a team's payroll seems to be moderately influential in predicting their chances of taking home a division crown.  Indeed, our Wald test for `salary` alone yields a p-value of `r salary_only_summary$coefficients["salary", "Pr(>|z|)"]`, allowing us to reject the null hypothesis ($H_0 : \beta_{salary} = 0$) for any reasonable value for $\alpha$.  So what happens when we look at our salary model's misclassification rate?

```{r}
salary_prediction <- ifelse(predict(salary_only_model, 
                                    bbproj_tst, 
                                    type = "response") > 0.5, "Y", "N")
(prevalence = table(bbproj_tst$DivWin) / nrow(bbproj_tst))
(salary_misclass = mean(salary_prediction != bbproj_tst$DivWin))
```

First, let's examine prevalence of division winners.  We see that `r prevalence[2] * 100`% of the teams were division winners, which makes sense, since there are 6 divisions and 30 MLB teams, therefore you will only have 6 division winners per year.  Our salary model has a misclassification rate of `r round(salary_misclass, 3)`, which is worse than our prevalence.  We would have a better misclassification rate if we simply stated that there are no division winners!  We can certainly do better than this.

## Methodology ##

Similar to the MLR section, the ultimate goal of this thread is to find a logisitic regression model that predicts well and is easily interpretible.  To facilitate interpretibility, we utilize the `step` function to capture significant predictors using both AIC and BIC criteria, searching "forward", "backward", and "stepwise".  We strive to minimize the number of predictors while maximizing the model's predictive capabilities.

To predict efficiently, we develop Bayes classifiers based on the models and evaluate them by calculating their sensitivity, specificity, and misclassification rate using our test dataset from the 2014, 2015, and 2016 MLB seasons.  Further, we optimize the classifiers by choosing a cutoff value that minimizes the misclassification rate while maintaining a small delta between sensitivity and specificity.

### Candidate Logistic Regression Models ###

We will begin our search for a better classifier by setting up an initial logistic regression model contain all of the predictors we would like to evaluate.  Then, we will proceed to eliminate predictors using backwards, forwards, and stepwise AIC and BIC searches.  See Appendix A for a complete evaluation of the remaining model derivations and classifications.  The following will detail the methodology using our best candidate model.

```{r warning=FALSE}
scope <- DivWin ~ W + R + AB + H + X2B + X3B + HR + BB + SO + SB + CS + HBP + 
  SF + RA + ER + ERA + CG + SHO + SV + IPouts + HA  + HRA + BBA + SOA + E + 
  DP + FP + attendance + BPF + PPF + salary + RBI + GIDP + IBB + TB + SLG + 
  OBP + OPS + WHIP + BABIP + RC + X1B + uBB + wOBA
start_model <- glm(DivWin ~ 1, data = bbproj_trn, family = binomial)
n <- length(resid(start_model))
```

#### Forward Search: BIC Model ####

```{r warning=FALSE}
bic_model <- step(start_model, direction = "forward", scope = scope, 
                  k = log(n), trace = 0)
summary(bic_model)
```

Our forward search using BIC yields the following logistic model

\[
\log \bigg(\frac{P[DivWin = 1]}{1 - P[DivWin = 1]} \bigg) = \beta_0 + \beta_W W + \beta_{X2B} X2B
\]

where the log odds of a team winning their division is dependent upon wins and doubles.

##### Diagnostics: BIC Model ####

Next, we will create a function that will evaluate this model using a confusion matrix and calculate its sensitivity, specificity, and its misclassification rate (the `classify_and_diagnose` function code can be found in [Appendix A](#classify_and_diagnose)).  Then we will start by examining a default cutoff value of 0.5.

```{r classify_and_diagnose, echo = FALSE}
classify_and_diagnose = function(model, data = bbproj_tst, 
                                 actual = bbproj_tst$DivWin, 
                                 pos = "Y", neg = "N", cutoff = 0.5) {
  # Generate a classifier given the model, data, cutoff, and positive and
  # negative responses
  pred = ifelse(predict(model, 
                        data, 
                        type = "response") > cutoff, pos, neg)
  
  # Generate the confusion matrix
  conf_mat = table(prediction = pred, actual = actual)

  # Calculate sensitivity, specificity, and the misclassification rate and
  # return them plus the confusion matrix
  list(confusion_matrix = conf_mat, 
       sensitivity = conf_mat[2, 2] / sum(conf_mat[, 2]), 
       specificity = conf_mat[1, 1] / sum(conf_mat[, 1]), 
       misclassification = mean(pred != actual))
}
```

```{r}
(bic_diag <- classify_and_diagnose(bic_model))
```

Here, we beat the salary only model along with the prevalence with a misclassification rate of `r round(bic_diag$misclassification, 3)`.  Our specificity looks great for our forward BIC model at `r round(bic_diag$specificity, 3)`.  Our `r bic_diag$confusion_matrix[1, 2]` false negatives could come down, however, with an adjustment to our cutoff value.

#### Find an Optimal Cutoff ####

Next we will define a function that will loop through a vector of potential cutoffs to isolate one that will produce the smallest misclassification rate with a minimal differential between sensitivity and specificity (see [Appendix A](#opt_logistic_cutoff) for the `opt_logistic_cutoff` function's definition).

```{r opt_logistic_cutoff, echo = FALSE}
opt_logistic_cutoff = function(model, cut_start = 0.01, cut_end = 0.99, 
                               data = bbproj_tst, actual = bbproj_tst$DivWin,
                               pos = "Y", neg = "N", plotit = TRUE) {
  # Loop through potential cutoffs from cut_start to cut_end to determine a 
  # cutoff that produces the lowest misclassification rate with the smallest 
  # delta between sensitivity and specificity
  cutoffs = seq(cut_start, cut_end, by = 0.01)
  sens = rep(0, length(cutoffs))
  spec = rep(0, length(cutoffs))
  misclass = rep(0, length(cutoffs))
  delta = rep(0, length(cutoffs))
  for (i in 1:length(cutoffs)) {
    diagnostics = classify_and_diagnose(model, 
                                        data = data, 
                                        actual = actual,
                                        pos = pos,
                                        neg = neg,
                                        cutoff = cutoffs[i])
    sens[i] = diagnostics$sensitivity
    spec[i] = diagnostics$specificity
    misclass[i] = diagnostics$misclassification
    delta[i] = abs(diagnostics$sensitivity - diagnostics$specificity)
  }
  
  # Get the indicies of the smallest misclassification rates
  min_misclass = which(misclass == min(misclass))
  
  # Get the smallest delta between sensitivity and specificity at the 
  # identified misclassification indicies
  min_delta = min_misclass[which.min(delta[min_misclass])]
  
  # Plot sensitivity, specificity, and misclassification if requested
  if (plotit) {
    plot(sens ~ cutoffs,
         xlab = "Cutoff",
         ylab = "Sensitivity/Specificity",
         main = "Sensitivity and Specificity at Varied Cutoffs",
         col = "tomato",
         type = "b",
         ylim = c(0, 1),
         pch = 20)
    lines(spec ~ cutoffs, 
          col = "darkslategray4", 
          type = "b",
          pch = 20)
    lines(misclass ~ cutoffs, 
          col = "darkorange", 
          type = "b",
          pch = 20)
    abline(v = cutoffs[min_delta], lty = 2)
    legend("topright", c("Sensitivity", 
                         "Specificity", 
                         "Misclassification"),
           col = c("tomato", "darkslategray4", "darkorange"),
           lwd = 1,
           pch = 20)
  }
  
  # Return the misclassification, sensitivity, and specificity at the optimal
  # cutoff value
  c(cutoff = cutoffs[min_delta],
    misclass = misclass[min_delta], 
    sensitivity = sens[min_delta],
    specificity = spec[min_delta])
}
```

```{r}
(opt_cutoff = opt_logistic_cutoff(bic_model, cut_start = 0.1, cut_end = 0.8))
classify_and_diagnose(bic_model, cutoff = opt_cutoff["cutoff"])$confusion_matrix
```

Our routine finds an optimal cutoff value for our forward BIC model of `r opt_cutoff["cutoff"]`.  Our misclassification rate went down with our cutoff adjustment to `r round(opt_cutoff["misclass"], 3)`.  Additionally, our sensitivity went up significantly (`r round(opt_cutoff["sensitivity"], 3)`) and we only had a modest reduction in specificity (`r round(opt_cutoff["specificity"], 3)`).  This model looks to be exceptionally adept at classifying division winners, and `salary` is not even a predictor!

```{r glm_back_bic, warning = FALSE, echo=FALSE}
formula <- formula(scope)
back_bic_model <- step(glm(formula, data = bbproj_trn, family = binomial), 
                       direction = "backward", k = log(n), trace = 0)
back_bic_diag <- classify_and_diagnose(back_bic_model)
```

```{r glm_opt_back_bic, echo = FALSE}
opt_back_bic <- opt_logistic_cutoff(back_bic_model, 
                                    cut_start = 0.1, 
                                    cut_end = 0.8,
                                    plotit = FALSE)
opt_back_bic_diag <- classify_and_diagnose(back_bic_model, 
                                           cutoff = opt_back_bic["cutoff"])
```

```{r glm_forw_bic, echo = FALSE}
forw_bic_model <- step(start_model, direction = "forward", scope = scope, 
                       k = log(n), trace = 0)
forw_bic_diag <- classify_and_diagnose(forw_bic_model)
```

```{r glm_opt_forw_bic, echo = FALSE}
opt_forw_bic <- opt_logistic_cutoff(forw_bic_model, 
                                    cut_start = 0.1, 
                                    cut_end = 0.8,
                                    plotit = FALSE)
opt_forw_bic_diag <- classify_and_diagnose(forw_bic_model, 
                                           cutoff = opt_forw_bic["cutoff"])
```

```{r glm_step_bic, echo = FALSE}
step_bic_model <- step(start_model, direction = "both", scope = scope, 
                       k = log(n), trace = 0)
step_bic_diag <- classify_and_diagnose(step_bic_model)
```

```{r opt_glm_step_bic, echo = FALSE}
opt_step_bic <- opt_logistic_cutoff(step_bic_model, 
                                    cut_start = 0.1, 
                                    cut_end = 0.8,
                                    plotit = FALSE)
opt_step_bic_diag <- classify_and_diagnose(step_bic_model, 
                                           cutoff = opt_step_bic["cutoff"])
```

```{r glm_back_aic, warning = FALSE, echo = FALSE}
formula <- formula(scope)
back_aic_model <- step(glm(formula, data = bbproj_trn, family = binomial), 
                       direction = "backward", trace = 0)
back_aic_diag <- classify_and_diagnose(back_aic_model)
```

```{r opt_glm_back_aic, echo = FALSE}
opt_back_aic <- opt_logistic_cutoff(back_aic_model, 
                                    cut_start = 0.1, 
                                    cut_end = 0.8,
                                    plotit = FALSE)
opt_back_aic_diag <- classify_and_diagnose(back_aic_model, 
                                           cutoff = opt_back_aic["cutoff"])
```

```{r glm_forw_aic, echo = FALSE}
forw_aic_model <- step(start_model, direction = "forward", 
                       scope = scope, trace = 0)
forw_aic_diag <- classify_and_diagnose(forw_aic_model)
```

```{r opt_glm_forw_aic, echo = FALSE}
opt_forw_aic <- opt_logistic_cutoff(forw_aic_model, 
                                    cut_start = 0.1, 
                                    cut_end = 0.8,
                                    plotit = FALSE)
opt_forw_aic_diag <- classify_and_diagnose(forw_aic_model, 
                                           cutoff = opt_forw_aic["cutoff"])
```

```{r glm_step_aic, echo = FALSE}
step_aic_model <- step(start_model, direction = "both", 
                       scope = scope, trace = 0)
step_aic_diag <- classify_and_diagnose(step_aic_model)
```

```{r opt_glm_step_aic, echo = FALSE}
opt_step_aic <- opt_logistic_cutoff(step_aic_model, 
                                    cut_start = 0.1, 
                                    cut_end = 0.8,
                                    plotit = FALSE)
opt_step_aic_diag <- classify_and_diagnose(step_aic_model, 
                                           cutoff = opt_step_aic["cutoff"])
```

***

## Results ##

```{r include=FALSE}
logistic_results = data.frame(
  cutoff = c(forw_aic = 0.5,
             back_aic = 0.5,
             step_aic = 0.5,
             forw_bic = 0.5,
             back_bic = 0.5,
             step_bic = 0.5,
             opt_forw_aic = opt_forw_aic["cutoff"],
             opt_back_aic = opt_back_aic["cutoff"],
             opt_step_aic = opt_step_aic["cutoff"],
             opt_forw_bic = opt_forw_bic["cutoff"],
             opt_back_bic = opt_back_bic["cutoff"],
             opt_step_bic = opt_step_bic["cutoff"]),
  misclass = c(forw_aic = forw_aic_diag$misclassification,
               back_aic = back_aic_diag$misclassification,
               step_aic = step_aic_diag$misclassification,
               forw_bic = forw_bic_diag$misclassification,
               back_bic = back_bic_diag$misclassification,
               step_bic = step_bic_diag$misclassification,
               opt_forw_aic = opt_forw_aic_diag$misclassification,
               opt_back_aic = opt_back_aic_diag$misclassification,
               opt_step_aic = opt_step_aic_diag$misclassification,
               opt_forw_bic = opt_forw_bic_diag$misclassification,
               opt_back_bic = opt_back_bic_diag$misclassification,
               opt_step_bic = opt_step_bic_diag$misclassification),
  sensitivity = c(forw_aic = forw_aic_diag$sensitivity,
                  back_aic = back_aic_diag$sensitivity,
                  step_aic = step_aic_diag$sensitivity,
                  forw_bic = forw_bic_diag$sensitivity,
                  back_bic = back_bic_diag$sensitivity,
                  step_bic = step_bic_diag$sensitivity,
                  opt_forw_aic = opt_forw_aic_diag$sensitivity,
                  opt_back_aic = opt_back_aic_diag$sensitivity,
                  opt_step_aic = opt_step_aic_diag$sensitivity,
                  opt_forw_bic = opt_forw_bic_diag$sensitivity,
                  opt_back_bic = opt_back_bic_diag$sensitivity,
                  opt_step_bic = opt_step_bic_diag$sensitivity),
  specificity = c(forw_aic = forw_aic_diag$specificity,
                  back_aic = back_aic_diag$specificity,
                  step_aic = step_aic_diag$specificity,
                  forw_bic = forw_bic_diag$specificity,
                  back_bic = back_bic_diag$specificity,
                  step_bic = step_bic_diag$specificity,
                  opt_forw_aic = opt_forw_aic_diag$specificity,
                  opt_back_aic = opt_back_aic_diag$specificity,
                  opt_step_aic = opt_step_aic_diag$specificity,
                  opt_forw_bic = opt_forw_bic_diag$specificity,
                  opt_back_bic = opt_back_bic_diag$specificity,
                  opt_step_bic = opt_step_bic_diag$specificity),
  nparams = c(forw_aic = length(coef(forw_aic_model)),
              back_aic = length(coef(back_aic_model)),
              step_aic = length(coef(step_aic_model)),
              forw_bic = length(coef(forw_bic_model)),
              back_bic = length(coef(back_bic_model)),
              step_bic = length(coef(step_bic_model)),
              opt_forw_aic = length(coef(forw_aic_model)),
              opt_back_aic = length(coef(back_aic_model)),
              opt_step_aic = length(coef(step_aic_model)),
              opt_forw_bic = length(coef(forw_bic_model)),
              opt_back_bic = length(coef(back_bic_model)),
              opt_step_bic = length(coef(step_bic_model))),
  fn = c(forw_aic = forw_aic_diag$confusion_matrix[1, 2],
         back_aic = back_aic_diag$confusion_matrix[1, 2],
         step_aic = step_aic_diag$confusion_matrix[1, 2],
         forw_bic = forw_bic_diag$confusion_matrix[1, 2],
         back_bic = back_bic_diag$confusion_matrix[1, 2],
         step_bic = step_bic_diag$confusion_matrix[1, 2],
         opt_forw_aic = opt_forw_aic_diag$confusion_matrix[1, 2],
         opt_back_aic = opt_back_aic_diag$confusion_matrix[1, 2],
         opt_step_aic = opt_step_aic_diag$confusion_matrix[1, 2],
         opt_forw_bic = opt_forw_bic_diag$confusion_matrix[1, 2],
         opt_back_bic = opt_back_bic_diag$confusion_matrix[1, 2],
         opt_step_bic = opt_step_bic_diag$confusion_matrix[1, 2]),
  fp = c(forw_aic = forw_aic_diag$confusion_matrix[2, 1],
         back_aic = back_aic_diag$confusion_matrix[2, 1],
         step_aic = step_aic_diag$confusion_matrix[2, 1],
         forw_bic = forw_bic_diag$confusion_matrix[2, 1],
         back_bic = back_bic_diag$confusion_matrix[2, 1],
         step_bic = step_bic_diag$confusion_matrix[2, 1],
         opt_forw_aic = opt_forw_aic_diag$confusion_matrix[2, 1],
         opt_back_aic = opt_back_aic_diag$confusion_matrix[2, 1],
         opt_step_aic = opt_step_aic_diag$confusion_matrix[2, 1],
         opt_forw_bic = opt_forw_bic_diag$confusion_matrix[2, 1],
         opt_back_bic = opt_back_bic_diag$confusion_matrix[2, 1],
         opt_step_bic = opt_step_bic_diag$confusion_matrix[2, 1])
)
row.names(logistic_results) = c("Forward AIC",
                                "Backward AIC",
                                "Stepwise AIC",
                                "Forward BIC",
                                "Backward BIC",
                                "Stepwise BIC",
                                "Forward AIC (Optimal Cutoff)",
                                "Backward AIC (Optimal Cutoff)",
                                "Stepwise AIC (Optimal Cutoff)",
                                "Forward BIC (Optimal Cutoff)",
                                "Backward BIC (Optimal Cutoff)",
                                "Stepwise BIC (Optimal Cutoff)")
logistic_col_names = c("Cutoff",
                       "Misclassification Rate",
                       "Sensitivity",
                       "Specificity",
                       "p",
                       "False Negatives",
                       "False Positives")
```

```{r}
library(knitr)
kable(logistic_results, col.names = logistic_col_names, 
      caption = "Logistic Regression Model Result Summary")
```

### And the Winning Logistic Regression Model is... ###

Forward-search BIC model with an optimal cutoff of 0.3.

\[
\log \bigg(\frac{P[DivWin = 1]}{1 - P[DivWin = 1]} \bigg) = \beta_0 + \beta_W W + \beta_{X2B} X2B
\]

***

## Discussion ##

We choose the forward-search BIC model with a cutoff value of 0.3 as our best predictive model.  While there are a few models that have an equivalent minimal misclassification rate, the forward BIC model has the least number of predictors and therefore the easiest to interpret.  Additionally, the sensitivity and specificity (false negatives and false positives, respectively) are minimized and nearly equivalent.

Our winning model tells us that a team's win total `W` and double tally `X2B` has a significant relationship with that team's probability of winning their division.  The relationship with `W` is fairly self evident and quite boring given the definition of a division winner - the team  with the most wins in their division at the end of the season is declared the division champ.  Interestingly, however, there is a somewhat-significant negative relationship with doubles.  That is, given two teams with the same number of wins, the team with the *fewer* number of doubles would have a higher probability of winning their division.  What does this mean?  Well, one explanation is, given all else equal, it's possible the game favors teams proficient at small ball - being able to manufacture runs with walks, bunts, steals, and sacrifice flies - rather than a team's capacity of lacing ropes to the alley in left-center.

***

# Apendices #

## Appendix A - Logistic Regression Models

### Classify and Diagnose Function {#classify_and_diagnose}

```{r ref.label = "classify_and_diagnose", eval = FALSE}
```

### Optimal Logistic Cutoff Function {#opt_logistic_cutoff}

```{r ref.label = "opt_logistic_cutoff", eval = FALSE}
```

### Backward Search: BIC Model

```{r ref.label = "glm_back_bic", eval = FALSE}
```

```{r}
summary(back_bic_model)
back_bic_diag
```

#### Optimal Cutoff

```{r ref.label = "opt_glm_back_bic", eval = FALSE}
```

```{r}
opt_logistic_cutoff(back_bic_model, cut_start = 0.1, cut_end = 0.8)
opt_back_bic_diag$confusion_matrix
```

### Forward Search: BIC Model

```{r ref.label = "glm_forw_bic", eval = FALSE}
```

```{r}
summary(forw_bic_model)
forw_bic_diag
```

#### Optimal Cutoff

```{r ref.label = "opt_glm_forw_bic", eval = FALSE}
```

```{r}
opt_logistic_cutoff(forw_bic_model, cut_start = 0.1, cut_end = 0.8)
opt_forw_bic_diag$confusion_matrix
```

### Stepwise Search: BIC Model

```{r ref.label = "glm_step_bic", eval = FALSE}
```

```{r}
summary(step_bic_model)
step_bic_diag
```

#### Optimal Cutoff

```{r ref.label = "opt_glm_step_bic", eval = FALSE}
```

```{r}
opt_logistic_cutoff(step_bic_model, cut_start = 0.1, cut_end = 0.8)
opt_step_bic_diag$confusion_matrix
```

### Backward Search: AIC Model

```{r ref.label = "glm_back_aic", eval = FALSE}
```

```{r}
summary(back_aic_model)
back_aic_diag <- classify_and_diagnose(back_aic_model)
```

#### Optimal Cutoff

```{r ref.label = "opt_glm_back_aic", eval = FALSE}
```

```{r}
opt_logistic_cutoff(back_aic_model, cut_start = 0.1, cut_end = 0.8)
opt_back_aic_diag$confusion_matrix
```

### Forward Search: AIC Model

```{r ref.label = "glm_forw_aic", eval = FALSE}
```

```{r}
summary(forw_aic_model)
forw_aic_diag
```

#### Optimal Cutoff

```{r ref.label = "opt_glm_forw_aic", eval = FALSE}
```

```{r}
opt_logistic_cutoff(forw_aic_model, cut_start = 0.1, cut_end = 0.8)
opt_forw_aic_diag$confusion_matrix
```

### Stepwise Search: AIC Model

```{r ref.label = "glm_step_aic", eval = FALSE}
```

```{r}
summary(step_aic_model)
step_aic_diag
```

#### Optimal Cutoff

```{r ref.label = "opt_glm_step_aic", eval = FALSE}
```

```{r}
opt_logistic_cutoff(step_aic_model, cut_start = 0.1, cut_end = 0.8)
opt_step_aic_diag$confusion_matrix
```
